{"file_contents":{"ai_service.py":{"content":"import os\nimport logging\ntry:\n    from google import genai\n    from google.genai import types\n    # Configure Gemini AI client only if API key is available\n    api_key = os.environ.get(\"GEMINI_API_KEY\")\n    if api_key:\n        client = genai.Client(api_key=api_key)\n        types_available = True\n    else:\n        client = None\n        types_available = False\n        logging.warning(\"GEMINI_API_KEY not provided - AI features will be disabled\")\nexcept ImportError:\n    genai = None\n    client = None\n    types = None\n    types_available = False\n    logging.warning(\"Google Genai library not available\")\n\ndef get_custom_prompt():\n    \"\"\"Get custom AI prompt from database\"\"\"\n    try:\n        from app import app, db\n        from models import SystemSettings\n        \n        with app.app_context():\n            setting = SystemSettings.query.filter_by(setting_key='ai_prompt').first()\n            if setting and setting.setting_value:\n                return setting.setting_value\n    except Exception as e:\n        logging.error(f\"Erro ao obter prompt personalizado: {e}\")\n    \n    # Default prompt if none configured\n    return \"\"\"Voc√™ √© um assistente virtual inteligente para WhatsApp.\nVoc√™ deve responder de forma √∫til, amig√°vel e profissional.\n\nInstru√ß√µes:\n- Responda em portugu√™s brasileiro\n- Seja conciso mas informativo\n- Mantenha um tom amig√°vel e profissional\n- Se n√£o souber algo, seja honesto sobre isso\n- Evite respostas muito longas para WhatsApp\"\"\"\n\ndef generate_ai_response(user_message: str, conversation_history=None) -> str:\n    \"\"\"\n    Generate AI response using Gemini API\n    \n    Args:\n        user_message: The user's message\n        conversation_history: List of previous messages for context\n    \n    Returns:\n        AI generated response\n    \"\"\"\n    try:\n        if not client:\n            return \"Desculpe, o servi√ßo de IA n√£o est√° dispon√≠vel no momento.\"\n            \n        # Get custom prompt\n        custom_prompt = get_custom_prompt()\n        \n        # Build context from conversation history\n        context = \"\"\n        if conversation_history:\n            context = \"Hist√≥rico da conversa:\\n\"\n            for msg in conversation_history[-5:]:  # Last 5 messages for context\n                sender = \"Usu√°rio\" if msg.is_from_user else \"AsA\"\n                context += f\"{sender}: {msg.content}\\n\"\n            context += \"\\n\"\n        \n        # Create prompt for AI\n        prompt = f\"\"\"\n        {custom_prompt}\n        \n        {context}\n        \n        Mensagem atual do usu√°rio: {user_message}\n        \"\"\"\n        \n        response = client.models.generate_content(\n            model=\"gemini-2.5-flash\",\n            contents=prompt\n        )\n        \n        if response.text:\n            return response.text.strip()\n        else:\n            return \"Desculpe, n√£o consegui processar sua mensagem no momento. Tente novamente.\"\n            \n    except Exception as e:\n        logging.error(f\"Erro ao gerar resposta AI: {e}\")\n        return \"Desculpe, estou com problemas t√©cnicos. Tente novamente em alguns minutos.\"\n\ndef test_prompt_response(user_message: str, custom_prompt: str) -> str:\n    \"\"\"Test a prompt with a message without saving to database\"\"\"\n    try:\n        if not client:\n            return \"Servi√ßo de IA n√£o dispon√≠vel\"\n            \n        prompt = f\"\"\"\n        {custom_prompt}\n        \n        Mensagem atual do usu√°rio: {user_message}\n        \"\"\"\n        \n        response = client.models.generate_content(\n            model=\"gemini-2.5-flash\",\n            contents=prompt\n        )\n        \n        if response.text:\n            return response.text.strip()\n        else:\n            return \"N√£o consegui gerar resposta\"\n            \n    except Exception as e:\n        logging.error(f\"Erro ao testar prompt: {e}\")\n        return f\"Erro: {str(e)}\"\n\ndef analyze_message_intent(message: str) -> dict:\n    \"\"\"\n    Analyze message intent to determine best response strategy\n    \n    Returns:\n        Dict with intent analysis results\n    \"\"\"\n    try:\n        if not client or not types_available:\n            return {\"tipo\": \"outro\", \"urgencia\": \"baixo\", \"requer_humano\": False}\n            \n        prompt = f\"\"\"\n        Analise a seguinte mensagem do WhatsApp e determine:\n        1. Se √© uma pergunta, sauda√ß√£o, pedido de informa√ß√£o, reclama√ß√£o, etc.\n        2. O n√≠vel de urg√™ncia (baixo, m√©dio, alto)\n        3. Se requer resposta humana ou pode ser respondida automaticamente\n        \n        Mensagem: \"{message}\"\n        \n        Responda apenas com JSON no formato:\n        {{\"tipo\": \"pergunta|saudacao|pedido|reclamacao|outro\", \"urgencia\": \"baixo|medio|alto\", \"requer_humano\": true|false}}\n        \"\"\"\n        \n        if types:\n            response = client.models.generate_content(\n                model=\"gemini-2.5-flash\",\n                contents=prompt,\n                config=types.GenerateContentConfig(\n                    response_mime_type=\"application/json\"\n                )\n            )\n        else:\n            response = client.models.generate_content(\n                model=\"gemini-2.5-flash\",\n                contents=prompt\n            )\n        \n        if response.text:\n            import json\n            return json.loads(response.text)\n        else:\n            return {\"tipo\": \"outro\", \"urgencia\": \"baixo\", \"requer_humano\": False}\n            \n    except Exception as e:\n        logging.error(f\"Erro ao analisar inten√ß√£o da mensagem: {e}\")\n        return {\"tipo\": \"outro\", \"urgencia\": \"baixo\", \"requer_humano\": False}\n","size_bytes":5549},"app.py":{"content":"import os\nimport logging\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom sqlalchemy.orm import DeclarativeBase\nfrom werkzeug.middleware.proxy_fix import ProxyFix\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\n\nclass Base(DeclarativeBase):\n    pass\n\ndb = SQLAlchemy(model_class=Base)\n\n# Create the app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\", \"asa-secret-key-2024\")\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n\n# Configure the database\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = os.environ.get(\"DATABASE_URL\", \"sqlite:///asa_whatsapp.db\")\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    \"pool_recycle\": 300,\n    \"pool_pre_ping\": True,\n}\n\n# Initialize the app with the extension\ndb.init_app(app)\n\nwith app.app_context():\n    # Import models to create tables\n    import models  # noqa: F401\n    db.create_all()\n    logging.info(\"Database tables created successfully\")\n","size_bytes":944},"baileys_service.py":{"content":"import os\nimport requests\nimport logging\nimport subprocess\nimport threading\nimport time\nfrom typing import Dict, Optional\n\nclass BaileysService:\n    \"\"\"Servi√ßo para gerenciar o WhatsApp via Baileys local\"\"\"\n    \n    def __init__(self):\n        self.base_url = 'http://localhost:3001'\n        self.process = None\n        self.is_running = False\n        \n        # Iniciar o servi√ßo Node.js automaticamente\n        self.start_baileys_service()\n    \n    def start_baileys_service(self):\n        \"\"\"Iniciar o servi√ßo Baileys em background\"\"\"\n        try:\n            if not self.is_running:\n                logging.info(\"üöÄ Iniciando servi√ßo Baileys...\")\n                \n                # Verificar se Node.js est√° dispon√≠vel\n                result = subprocess.run(['node', '--version'], capture_output=True, text=True)\n                if result.returncode != 0:\n                    logging.error(\"Node.js n√£o encontrado!\")\n                    return\n                \n                # Iniciar o processo Node.js\n                self.process = subprocess.Popen(\n                    ['node', 'whatsapp_baileys_simple.js'],\n                    stdout=subprocess.PIPE,\n                    stderr=subprocess.PIPE,\n                    text=True\n                )\n                \n                self.is_running = True\n                \n                # Aguardar um pouco para o servi√ßo iniciar\n                time.sleep(3)\n                \n                # Verificar se est√° rodando\n                if self.process.poll() is None:\n                    logging.info(\"‚úÖ Servi√ßo Baileys iniciado com sucesso!\")\n                else:\n                    logging.error(\"‚ùå Falha ao iniciar servi√ßo Baileys\")\n                    self.is_running = False\n                \n        except Exception as e:\n            logging.error(f\"Erro ao iniciar Baileys: {e}\")\n            self.is_running = False\n    \n    def stop_baileys_service(self):\n        \"\"\"Parar o servi√ßo Baileys\"\"\"\n        try:\n            if self.process and self.process.poll() is None:\n                logging.info(\"üõë Parando servi√ßo Baileys...\")\n                self.process.terminate()\n                self.process.wait(timeout=5)\n                self.is_running = False\n                logging.info(\"‚úÖ Servi√ßo Baileys parado\")\n        except Exception as e:\n            logging.error(f\"Erro ao parar Baileys: {e}\")\n    \n    def _make_request(self, method: str, endpoint: str, data: Dict = None) -> Dict:\n        \"\"\"Fazer requisi√ß√£o para o servi√ßo Baileys\"\"\"\n        try:\n            if not self.is_running:\n                self.start_baileys_service()\n                time.sleep(2)\n            \n            url = f\"{self.base_url}{endpoint}\"\n            \n            if method.upper() == 'GET':\n                response = requests.get(url, timeout=10)\n            elif method.upper() == 'POST':\n                response = requests.post(url, json=data or {}, timeout=10)\n            else:\n                return {\"success\": False, \"error\": \"M√©todo n√£o suportado\"}\n            \n            if response.status_code == 200:\n                return response.json()\n            else:\n                return {\"success\": False, \"error\": f\"Status {response.status_code}: {response.text}\"}\n                \n        except requests.exceptions.ConnectionError:\n            return {\"success\": False, \"error\": \"Servi√ßo WhatsApp n√£o est√° rodando\"}\n        except requests.exceptions.Timeout:\n            return {\"success\": False, \"error\": \"Timeout na conex√£o\"}\n        except Exception as e:\n            return {\"success\": False, \"error\": str(e)}\n    \n    def get_connection_status(self) -> Dict:\n        \"\"\"Obter status da conex√£o\"\"\"\n        return self._make_request('GET', '/status')\n    \n    def get_qr_code(self) -> Dict:\n        \"\"\"Obter QR Code\"\"\"\n        return self._make_request('GET', '/qr')\n    \n    def send_message(self, phone: str, message: str) -> Dict:\n        \"\"\"Enviar mensagem\"\"\"\n        return self._make_request('POST', '/send-message', {\n            'phone': phone,\n            'message': message\n        })\n    \n    def set_typing(self, phone: str, typing: bool = True) -> Dict:\n        \"\"\"Definir status de digita√ß√£o\"\"\"\n        return self._make_request('POST', '/set-typing', {\n            'phone': phone,\n            'typing': typing\n        })\n\n# Inst√¢ncia global\nbaileys_service = BaileysService()","size_bytes":4402},"evolution_api_service.py":{"content":"import os\nimport requests\nimport logging\nimport json\nfrom datetime import datetime\nfrom typing import Dict, Optional\n\nclass EvolutionAPIService:\n    \"\"\"Servi√ßo para integra√ß√£o com Evolution API\"\"\"\n    \n    def __init__(self):\n        # Configura√ß√µes da Evolution API\n        self.base_url = os.environ.get('EVOLUTION_API_URL', 'http://localhost:8080')\n        self.api_key = os.environ.get('EVOLUTION_API_KEY', 'B6D711FCDE4D4FD5936544120E713976')\n        self.instance_name = os.environ.get('EVOLUTION_INSTANCE_NAME', 'asa_whatsapp')\n        \n        self.headers = {\n            'Content-Type': 'application/json',\n            'apikey': self.api_key\n        }\n        \n        logging.info(f\"Evolution API configurada: {self.base_url}\")\n    \n    def create_instance(self) -> Dict:\n        \"\"\"Criar uma nova inst√¢ncia do WhatsApp\"\"\"\n        try:\n            url = f\"{self.base_url}/instance/create\"\n            data = {\n                \"instanceName\": self.instance_name,\n                \"token\": self.api_key,\n                \"qrcode\": True,\n                \"webhookUrl\": f\"{os.environ.get('WEBHOOK_URL', 'http://localhost:5000')}/webhook/evolution\",\n                \"webhookByEvents\": True,\n                \"webhookBase64\": False,\n                \"events\": [\n                    \"APPLICATION_STARTUP\",\n                    \"QRCODE_UPDATED\", \n                    \"CONNECTION_UPDATE\",\n                    \"MESSAGES_UPSERT\",\n                    \"MESSAGES_UPDATE\",\n                    \"SEND_MESSAGE\"\n                ]\n            }\n            \n            response = requests.post(url, headers=self.headers, json=data)\n            \n            if response.status_code == 201:\n                result = response.json()\n                logging.info(f\"Inst√¢ncia criada: {result}\")\n                return {\"success\": True, \"data\": result}\n            else:\n                logging.error(f\"Erro ao criar inst√¢ncia: {response.text}\")\n                return {\"success\": False, \"error\": response.text}\n                \n        except Exception as e:\n            logging.error(f\"Erro ao criar inst√¢ncia: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    def get_connection_state(self) -> Dict:\n        \"\"\"Obter estado da conex√£o\"\"\"\n        try:\n            url = f\"{self.base_url}/instance/connectionState/{self.instance_name}\"\n            response = requests.get(url, headers=self.headers, timeout=5)\n            \n            if response.status_code == 200:\n                result = response.json()\n                return {\"success\": True, \"data\": result}\n            else:\n                return {\"success\": False, \"error\": response.text}\n                \n        except requests.exceptions.ConnectionError:\n            return {\"success\": False, \"error\": \"Evolution API n√£o est√° rodando. Configure em /evolution-setup\"}\n        except requests.exceptions.Timeout:\n            return {\"success\": False, \"error\": \"Timeout ao conectar com Evolution API\"}\n        except Exception as e:\n            logging.error(f\"Erro ao obter estado da conex√£o: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    def get_qr_code(self) -> Dict:\n        \"\"\"Obter c√≥digo QR para conex√£o\"\"\"\n        try:\n            url = f\"{self.base_url}/instance/connect/{self.instance_name}\"\n            response = requests.get(url, headers=self.headers)\n            \n            if response.status_code == 200:\n                result = response.json()\n                if 'qrcode' in result:\n                    return {\n                        \"success\": True, \n                        \"qr_code\": result.get('qrcode', {}).get('code', ''),\n                        \"qr_base64\": result.get('qrcode', {}).get('base64', '')\n                    }\n                else:\n                    return {\"success\": False, \"error\": \"QR Code n√£o dispon√≠vel\"}\n            else:\n                return {\"success\": False, \"error\": response.text}\n                \n        except Exception as e:\n            logging.error(f\"Erro ao obter QR Code: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    def send_message(self, phone: str, message: str) -> Dict:\n        \"\"\"Enviar mensagem via Evolution API\"\"\"\n        try:\n            # Garantir formato correto do n√∫mero\n            if not phone.endswith('@s.whatsapp.net'):\n                # Remover caracteres especiais e adicionar c√≥digo do pa√≠s se necess√°rio\n                clean_phone = ''.join(filter(str.isdigit, phone))\n                if not clean_phone.startswith('55'):  # Brasil\n                    clean_phone = '55' + clean_phone\n                phone = f\"{clean_phone}@s.whatsapp.net\"\n            \n            url = f\"{self.base_url}/message/sendText/{self.instance_name}\"\n            data = {\n                \"number\": phone,\n                \"text\": message\n            }\n            \n            response = requests.post(url, headers=self.headers, json=data)\n            \n            if response.status_code == 201:\n                result = response.json()\n                logging.info(f\"Mensagem enviada para {phone}: {message[:50]}...\")\n                return {\"success\": True, \"data\": result}\n            else:\n                logging.error(f\"Erro ao enviar mensagem: {response.text}\")\n                return {\"success\": False, \"error\": response.text}\n                \n        except Exception as e:\n            logging.error(f\"Erro ao enviar mensagem: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    def set_typing(self, phone: str, typing: bool = True) -> Dict:\n        \"\"\"Simular digita√ß√£o\"\"\"\n        try:\n            if not phone.endswith('@s.whatsapp.net'):\n                clean_phone = ''.join(filter(str.isdigit, phone))\n                if not clean_phone.startswith('55'):\n                    clean_phone = '55' + clean_phone\n                phone = f\"{clean_phone}@s.whatsapp.net\"\n            \n            url = f\"{self.base_url}/chat/presence/{self.instance_name}\"\n            data = {\n                \"number\": phone,\n                \"presence\": \"composing\" if typing else \"paused\"\n            }\n            \n            response = requests.post(url, headers=self.headers, json=data)\n            return {\"success\": response.status_code == 201}\n            \n        except Exception as e:\n            logging.error(f\"Erro ao definir digita√ß√£o: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    def disconnect_instance(self) -> Dict:\n        \"\"\"Desconectar inst√¢ncia\"\"\"\n        try:\n            url = f\"{self.base_url}/instance/logout/{self.instance_name}\"\n            response = requests.delete(url, headers=self.headers)\n            \n            if response.status_code == 200:\n                return {\"success\": True, \"message\": \"Inst√¢ncia desconectada\"}\n            else:\n                return {\"success\": False, \"error\": response.text}\n                \n        except Exception as e:\n            logging.error(f\"Erro ao desconectar inst√¢ncia: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    def get_instance_info(self) -> Dict:\n        \"\"\"Obter informa√ß√µes da inst√¢ncia\"\"\"\n        try:\n            url = f\"{self.base_url}/instance/fetchInstances\"\n            response = requests.get(url, headers=self.headers)\n            \n            if response.status_code == 200:\n                instances = response.json()\n                for instance in instances:\n                    if instance.get('instanceName') == self.instance_name:\n                        return {\"success\": True, \"data\": instance}\n                \n                return {\"success\": False, \"error\": \"Inst√¢ncia n√£o encontrada\"}\n            else:\n                return {\"success\": False, \"error\": response.text}\n                \n        except Exception as e:\n            logging.error(f\"Erro ao obter informa√ß√µes da inst√¢ncia: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n\n# Inst√¢ncia global do servi√ßo\nevolution_service = EvolutionAPIService()","size_bytes":8003},"main.py":{"content":"from app import app\nimport routes  # noqa: F401\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=5000, debug=True)\n","size_bytes":127},"models.py":{"content":"from datetime import datetime\nfrom app import db\n\nclass Conversation(db.Model):\n    \"\"\"Model for storing WhatsApp conversations\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    phone_number = db.Column(db.String(20), nullable=False)\n    contact_name = db.Column(db.String(100))\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    is_active = db.Column(db.Boolean, default=True)\n    ai_paused = db.Column(db.Boolean, default=False)  # True when human takes over\n    paused_at = db.Column(db.DateTime)  # When AI was paused\n    \n    # Relationship with messages\n    messages = db.relationship('Message', backref='conversation', lazy=True, cascade='all, delete-orphan')\n\nclass Message(db.Model):\n    \"\"\"Model for storing individual messages\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    conversation_id = db.Column(db.Integer, db.ForeignKey('conversation.id'), nullable=False)\n    content = db.Column(db.Text, nullable=False)\n    is_from_user = db.Column(db.Boolean, nullable=False)  # True if from user, False if from bot\n    message_type = db.Column(db.String(20), default='text')  # text, image, audio, etc.\n    timestamp = db.Column(db.DateTime, default=datetime.utcnow)\n    response_type = db.Column(db.String(20))  # 'standard', 'ai', or None for user messages\n\nclass AutoResponse(db.Model):\n    \"\"\"Model for storing automatic responses\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    trigger_keyword = db.Column(db.String(100), nullable=False, unique=True)\n    response_text = db.Column(db.Text, nullable=False)\n    is_active = db.Column(db.Boolean, default=True)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass SystemSettings(db.Model):\n    \"\"\"Model for storing system settings\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    setting_key = db.Column(db.String(50), nullable=False, unique=True)\n    setting_value = db.Column(db.Text)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass WhatsAppConnection(db.Model):\n    \"\"\"Model for storing WhatsApp connection status\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    is_connected = db.Column(db.Boolean, default=False)\n    qr_code = db.Column(db.Text)  # Base64 encoded QR code\n    last_connected = db.Column(db.DateTime)\n    session_data = db.Column(db.Text)  # Serialized session data\n","size_bytes":2550},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.2.0\",\n    \"flask-dance>=7.1.0\",\n    \"flask>=3.1.2\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"flask-login>=0.6.3\",\n    \"oauthlib>=3.3.1\",\n    \"pyjwt>=2.10.1\",\n    \"google-genai>=1.31.0\",\n    \"python-dotenv>=1.1.1\",\n    \"sift-stack-py>=0.8.4\",\n    \"sqlalchemy>=2.0.43\",\n    \"werkzeug>=3.1.3\",\n    \"requests>=2.32.5\",\n]\n","size_bytes":533},"replit.md":{"content":"# AsA - Sistema de Respostas Autom√°ticas WhatsApp\n\n## Overview\n\nAsA is a WhatsApp automatic response system that integrates AI-powered responses with traditional keyword-based automation. The system provides a web-based administrative interface for managing WhatsApp connections, conversations, and automated responses. It uses Google's Gemini AI for intelligent message processing and maintains conversation history for context-aware interactions.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Web Framework Architecture\n- **Flask-based Backend**: Uses Flask as the primary web framework with SQLAlchemy ORM for database operations\n- **Template Engine**: Jinja2 templating with Bootstrap 5 for responsive UI design\n- **Session Management**: Flask sessions for admin authentication with password hashing\n- **WSGI Configuration**: ProxyFix middleware for proper header handling in production environments\n\n### Database Design\n- **SQLAlchemy Models**: Five main entities - Conversation, Message, AutoResponse, SystemSettings, and WhatsAppConnection\n- **Relationship Management**: One-to-many relationship between conversations and messages with cascade deletion\n- **Connection Tracking**: Dedicated model for storing WhatsApp connection status and QR codes\n- **Settings Storage**: Key-value system for configurable application settings\n\n### WhatsApp Integration\n- **Service Layer**: WhatsAppService class manages connection simulation and message handling\n- **QR Code Generation**: Base64-encoded QR codes for WhatsApp Web connection simulation\n- **Message Processing**: Asynchronous message handling with typing indicators\n- **Connection Status**: Real-time connection monitoring and status updates\n\n### AI Integration\n- **Gemini AI**: Google Generative AI integration for intelligent response generation\n- **Context Management**: Maintains conversation history for contextual AI responses\n- **Intent Analysis**: Message intent classification for appropriate response routing\n- **Bilingual Support**: Portuguese-language responses with professional tone\n\n### Admin Interface\n- **Dashboard**: Statistics overview with conversation and message counts\n- **Conversation Management**: View and manage all WhatsApp conversations\n- **Response Configuration**: CRUD operations for automatic responses\n- **Authentication**: Simple password-based admin access control\n\n## External Dependencies\n\n### AI Services\n- **Google Generative AI**: Primary AI service using Gemini 2.5 Flash model for message generation and intent analysis\n- **API Authentication**: Requires GEMINI_API_KEY environment variable\n\n### Frontend Libraries\n- **Bootstrap 5**: CSS framework with dark theme support via CDN\n- **Font Awesome 6**: Icon library for UI elements\n- **Custom CSS**: WhatsApp-inspired color scheme and styling\n\n### Database\n- **SQLite**: Default database for development (configurable via DATABASE_URL)\n- **SQLAlchemy**: ORM with connection pooling and automatic table creation\n\n### Environment Configuration\n- **SESSION_SECRET**: Flask session encryption key\n- **ADMIN_PASSWORD**: Admin panel access password\n- **DATABASE_URL**: Database connection string (defaults to SQLite)\n- **GEMINI_API_KEY**: Google AI API authentication key","size_bytes":3277},"routes.py":{"content":"import os\nimport logging\nimport threading\nfrom datetime import datetime\nfrom flask import render_template, request, redirect, url_for, session, jsonify, flash\nfrom werkzeug.security import check_password_hash, generate_password_hash\nfrom app import app, db\nfrom models import Conversation, Message, AutoResponse, SystemSettings, WhatsAppConnection\nfrom whatsapp_service import whatsapp_service, simulate_incoming_messages\nfrom baileys_service import baileys_service\n\n# Admin credentials (in production, use proper user management)\nADMIN_PASSWORD_HASH = generate_password_hash(os.environ.get(\"ADMIN_PASSWORD\", \"admin123\"))\n\n@app.route('/')\ndef index():\n    \"\"\"Main page showing WhatsApp connection status\"\"\"\n    connection_status = whatsapp_service.get_connection_status()\n    return render_template('index_simple.html', connection_status=connection_status)\n\n@app.route('/generate_qr')\ndef generate_qr():\n    \"\"\"Generate new QR code for WhatsApp connection\"\"\"\n    qr_result = whatsapp_service.generate_qr_code()\n    \n    if qr_result:\n        # Get the QR image from database\n        with app.app_context():\n            connection = WhatsAppConnection.query.first()\n            if connection and connection.qr_code:\n                qr_image = connection.qr_code\n                logging.info(\"QR Code gerado - aguardando escaneamento\")\n                return jsonify({\n                    'success': True,\n                    'qr_code': qr_result,\n                    'qr_image': qr_image\n                })\n    \n    logging.error(\"Erro ao gerar QR Code\")\n    return jsonify({'success': False, 'error': 'Erro desconhecido'}), 500\n\n@app.route('/simulate_scan')\ndef simulate_scan():\n    \"\"\"Simular escaneamento do QR Code para teste\"\"\"\n    with app.app_context():\n        connection = WhatsAppConnection.query.first()\n        if connection:\n            connection.is_connected = True\n            connection.last_connected = datetime.utcnow()\n            connection.qr_code = None\n            db.session.commit()\n            \n    # Iniciar simula√ß√£o de mensagens ap√≥s \"conex√£o\"\n    simulate_incoming_messages()\n    \n    return jsonify({'status': 'connected'})\n\n@app.route('/connection_status')\ndef connection_status():\n    \"\"\"Get current connection status\"\"\"\n    status = whatsapp_service.get_connection_status()\n    return jsonify(status)\n\n@app.route('/whatsapp-apis')\ndef whatsapp_apis():\n    \"\"\"P√°gina explicativa sobre APIs WhatsApp dispon√≠veis\"\"\"\n    return render_template('whatsapp_apis.html')\n\n@app.route('/evolution-setup')\ndef evolution_setup():\n    \"\"\"P√°gina de configura√ß√£o da Evolution API\"\"\"\n    return render_template('evolution_setup.html')\n\n@app.route('/api/test-baileys')\ndef test_baileys():\n    \"\"\"Testar conex√£o com servi√ßo Baileys\"\"\"\n    try:\n        status = baileys_service.get_connection_status()\n        return jsonify(status)\n    except Exception as e:\n        return jsonify({\"success\": False, \"error\": str(e)})\n\n@app.route('/api/baileys-status')\ndef baileys_status():\n    \"\"\"Obter status do servi√ßo Baileys\"\"\"\n    try:\n        status = baileys_service.get_connection_status()\n        return jsonify(status)\n    except Exception as e:\n        return jsonify({\"success\": False, \"error\": str(e)})\n\n@app.route('/api/get-qr')\ndef get_qr_code():\n    \"\"\"Obter QR Code do Baileys para exibir na tela\"\"\"\n    try:\n        qr_result = baileys_service.get_qr_code()\n        return jsonify(qr_result)\n    except Exception as e:\n        return jsonify({\"success\": False, \"error\": str(e)})\n\n@app.route('/api/qr-updated', methods=['POST'])\ndef qr_updated():\n    \"\"\"Webhook para QR Code atualizado\"\"\"\n    try:\n        data = request.get_json()\n        qr_code = data.get('qr_code')\n        \n        if qr_code:\n            with app.app_context():\n                connection = WhatsAppConnection.query.first()\n                if not connection:\n                    connection = WhatsAppConnection()\n                    db.session.add(connection)\n                \n                connection.qr_code = qr_code\n                connection.is_connected = False\n                db.session.commit()\n                \n        return jsonify({'status': 'success'})\n    except Exception as e:\n        return jsonify({'status': 'error', 'message': str(e)}), 500\n\n@app.route('/api/connected', methods=['POST'])\ndef whatsapp_connected():\n    \"\"\"Webhook para WhatsApp conectado\"\"\"\n    try:\n        data = request.get_json()\n        \n        with app.app_context():\n            connection = WhatsAppConnection.query.first()\n            if not connection:\n                connection = WhatsAppConnection()\n                db.session.add(connection)\n            \n            connection.is_connected = True\n            connection.last_connected = datetime.utcnow()\n            connection.qr_code = None\n            db.session.commit()\n            \n        logging.info(\"‚úÖ WhatsApp conectado via Baileys!\")\n        return jsonify({'status': 'success'})\n    except Exception as e:\n        return jsonify({'status': 'error', 'message': str(e)}), 500\n\n@app.route('/api/disconnected', methods=['POST'])\ndef whatsapp_disconnected():\n    \"\"\"Webhook para WhatsApp desconectado\"\"\"\n    try:\n        with app.app_context():\n            connection = WhatsAppConnection.query.first()\n            if connection:\n                connection.is_connected = False\n                db.session.commit()\n                \n        logging.info(\"‚ùå WhatsApp desconectado\")\n        return jsonify({'status': 'success'})\n    except Exception as e:\n        return jsonify({'status': 'error', 'message': str(e)}), 500\n\n@app.route('/api/message-received', methods=['POST'])\ndef message_received():\n    \"\"\"Webhook para mensagem recebida\"\"\"\n    try:\n        data = request.get_json()\n        phone = data.get('phone')\n        message = data.get('message')\n        contact_name = data.get('contact_name', '')\n        \n        if phone and message:\n            logging.info(f\"üì® Mensagem recebida de {phone}: {message}\")\n            whatsapp_service.process_incoming_message(phone, message, contact_name)\n            \n        return jsonify({'status': 'success'})\n    except Exception as e:\n        logging.error(f\"Erro ao processar mensagem: {e}\")\n        return jsonify({'status': 'error', 'message': str(e)}), 500\n\n@app.route('/admin/login', methods=['GET', 'POST'])\ndef admin_login():\n    \"\"\"Admin login page\"\"\"\n    if request.method == 'POST':\n        password = request.form.get('password', '')\n        if password and check_password_hash(ADMIN_PASSWORD_HASH, password):\n            session['admin_logged_in'] = True\n            return redirect(url_for('admin_dashboard'))\n        else:\n            flash('Senha incorreta', 'error')\n    \n    return render_template('admin_login.html')\n\n@app.route('/admin/logout')\ndef admin_logout():\n    \"\"\"Admin logout\"\"\"\n    session.pop('admin_logged_in', None)\n    return redirect(url_for('index'))\n\ndef admin_required(f):\n    \"\"\"Decorator to require admin login\"\"\"\n    def decorated_function(*args, **kwargs):\n        if not session.get('admin_logged_in'):\n            return redirect(url_for('admin_login'))\n        return f(*args, **kwargs)\n    decorated_function.__name__ = f.__name__\n    return decorated_function\n\n@app.route('/admin/dashboard')\n@admin_required\ndef admin_dashboard():\n    \"\"\"Admin dashboard\"\"\"\n    # Get statistics\n    total_conversations = Conversation.query.count()\n    total_messages = Message.query.count()\n    active_responses = AutoResponse.query.filter_by(is_active=True).count()\n    \n    recent_conversations = Conversation.query.order_by(\n        Conversation.updated_at.desc()\n    ).limit(5).all()\n    \n    stats = {\n        'total_conversations': total_conversations,\n        'total_messages': total_messages,\n        'active_responses': active_responses,\n        'recent_conversations': recent_conversations\n    }\n    \n    return render_template('admin_dashboard.html', stats=stats)\n\n@app.route('/admin/conversations')\n@admin_required\ndef admin_conversations():\n    \"\"\"View all conversations\"\"\"\n    page = request.args.get('page', 1, type=int)\n    conversations = Conversation.query.order_by(\n        Conversation.updated_at.desc()\n    ).paginate(\n        page=page, per_page=20, error_out=False\n    )\n    \n    return render_template('conversations.html', conversations=conversations)\n\n@app.route('/admin/conversation/<int:conversation_id>')\n@admin_required\ndef view_conversation(conversation_id):\n    \"\"\"View specific conversation details\"\"\"\n    conversation = Conversation.query.get_or_404(conversation_id)\n    messages = Message.query.filter_by(\n        conversation_id=conversation_id\n    ).order_by(Message.timestamp.asc()).all()\n    \n    return render_template('conversation_detail.html', \n                         conversation=conversation, messages=messages)\n\n@app.route('/admin/conversation/<int:conversation_id>/delete', methods=['POST'])\n@admin_required\ndef delete_conversation(conversation_id):\n    \"\"\"Delete a conversation\"\"\"\n    conversation = Conversation.query.get_or_404(conversation_id)\n    db.session.delete(conversation)\n    db.session.commit()\n    flash('Conversa exclu√≠da com sucesso', 'success')\n    return redirect(url_for('admin_conversations'))\n\n@app.route('/admin/responses')\n@admin_required\ndef admin_responses():\n    \"\"\"Manage auto responses\"\"\"\n    responses = AutoResponse.query.order_by(AutoResponse.created_at.desc()).all()\n    return render_template('responses.html', responses=responses)\n\n@app.route('/admin/ai-config', methods=['GET', 'POST'])\n@admin_required\ndef ai_config():\n    \"\"\"Configure AI prompt\"\"\"\n    if request.method == 'POST':\n        ai_prompt = request.form.get('ai_prompt')\n        \n        # Save or update AI prompt setting\n        setting = SystemSettings.query.filter_by(setting_key='ai_prompt').first()\n        if not setting:\n            setting = SystemSettings(setting_key='ai_prompt')\n            db.session.add(setting)\n        \n        setting.setting_value = ai_prompt\n        \n        try:\n            db.session.commit()\n            flash('Prompt da IA atualizado com sucesso!', 'success')\n        except Exception as e:\n            db.session.rollback()\n            flash(f'Erro ao salvar configura√ß√£o: {e}', 'error')\n        \n        return redirect(url_for('ai_config'))\n    \n    # Get current prompt\n    setting = SystemSettings.query.filter_by(setting_key='ai_prompt').first()\n    current_prompt = setting.setting_value if setting else None\n    \n    default_prompt = \"\"\"Voc√™ √© um assistente virtual inteligente para WhatsApp.\nVoc√™ deve responder de forma √∫til, amig√°vel e profissional.\n\nInstru√ß√µes:\n- Responda em portugu√™s brasileiro\n- Seja conciso mas informativo\n- Mantenha um tom amig√°vel e profissional\n- Se n√£o souber algo, seja honesto sobre isso\n- Evite respostas muito longas para WhatsApp\"\"\"\n    \n    return render_template('ai_config.html', \n                         current_prompt=current_prompt, \n                         default_prompt=default_prompt)\n\n@app.route('/admin/ai-config/test', methods=['POST'])\n@admin_required\ndef test_ai_prompt():\n    \"\"\"Test AI prompt with a message\"\"\"\n    from ai_service import test_prompt_response\n    \n    data = request.get_json()\n    message = data.get('message')\n    prompt = data.get('prompt')\n    \n    if not message or not prompt:\n        return jsonify({'success': False, 'error': 'Mensagem e prompt s√£o obrigat√≥rios'})\n    \n    try:\n        response = test_prompt_response(message, prompt)\n        return jsonify({'success': True, 'response': response})\n    except Exception as e:\n        return jsonify({'success': False, 'error': str(e)})\n\n@app.route('/admin/responses/add', methods=['GET', 'POST'])\n@admin_required\ndef add_response():\n    \"\"\"Add new auto response\"\"\"\n    if request.method == 'POST':\n        trigger_keyword = request.form.get('trigger_keyword')\n        response_text = request.form.get('response_text')\n        is_active = request.form.get('is_active') == 'on'\n        \n        response = AutoResponse()\n        response.trigger_keyword = trigger_keyword\n        response.response_text = response_text\n        response.is_active = is_active\n        \n        try:\n            db.session.add(response)\n            db.session.commit()\n            flash('Resposta autom√°tica adicionada com sucesso', 'success')\n            return redirect(url_for('admin_responses'))\n        except Exception as e:\n            db.session.rollback()\n            flash('Erro ao adicionar resposta: palavra-chave j√° existe', 'error')\n    \n    return render_template('add_response.html')\n\n@app.route('/admin/responses/<int:response_id>/edit', methods=['GET', 'POST'])\n@admin_required\ndef edit_response(response_id):\n    \"\"\"Edit auto response\"\"\"\n    response = AutoResponse.query.get_or_404(response_id)\n    \n    if request.method == 'POST':\n        response.trigger_keyword = request.form.get('trigger_keyword')\n        response.response_text = request.form.get('response_text')\n        response.is_active = request.form.get('is_active') == 'on'\n        \n        try:\n            db.session.commit()\n            flash('Resposta autom√°tica atualizada com sucesso', 'success')\n            return redirect(url_for('admin_responses'))\n        except Exception as e:\n            db.session.rollback()\n            flash('Erro ao atualizar resposta', 'error')\n    \n    return render_template('edit_response.html', response=response)\n\n@app.route('/admin/responses/<int:response_id>/delete', methods=['POST'])\n@admin_required\ndef delete_response(response_id):\n    \"\"\"Delete auto response\"\"\"\n    response = AutoResponse.query.get_or_404(response_id)\n    db.session.delete(response)\n    db.session.commit()\n    flash('Resposta autom√°tica exclu√≠da com sucesso', 'success')\n    return redirect(url_for('admin_responses'))\n\n@app.route('/api/simulate_message', methods=['POST'])\ndef simulate_message():\n    \"\"\"API endpoint to simulate incoming message (for testing)\"\"\"\n    data = request.get_json()\n    phone = data.get('phone', '5511999999999')\n    message = data.get('message', 'Teste')\n    name = data.get('name', 'Usu√°rio Teste')\n    \n    whatsapp_service.process_incoming_message(phone, message, name)\n    \n    return jsonify({'status': 'success'})\n\n@app.context_processor\ndef inject_admin_status():\n    \"\"\"Inject admin login status into templates\"\"\"\n    return {'admin_logged_in': session.get('admin_logged_in', False)}\n","size_bytes":14400},"whatsapp_baileys.js":{"content":"const { default: makeWASocket, DisconnectReason, useMultiFileAuthState } = require('@whiskeysockets/baileys');\nconst QRCode = require('qrcode');\nconst express = require('express');\nconst axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\n// Configura√ß√£o do servidor Express\nconst app = express();\napp.use(express.json());\n\n// Estado da conex√£o WhatsApp\nlet socket = null;\nlet qrCodeData = null;\nlet isConnected = false;\nlet connectionStatus = 'disconnected';\n\n// URL do servidor Python Flask\nconst FLASK_SERVER = 'http://localhost:5000';\n\n// Fun√ß√£o para notificar o Flask sobre mudan√ßas de status\nasync function notifyFlask(endpoint, data) {\n    try {\n        await axios.post(`${FLASK_SERVER}${endpoint}`, data, {\n            headers: { 'Content-Type': 'application/json' }\n        });\n    } catch (error) {\n        console.log('Erro ao notificar Flask:', error.message);\n    }\n}\n\n// Fun√ß√£o para conectar ao WhatsApp\nasync function connectToWhatsApp() {\n    try {\n        // Usar autentica√ß√£o multi-file para persistir a sess√£o\n        const { state, saveCreds } = await useMultiFileAuthState('./auth_info');\n        \n        socket = makeWASocket({\n            auth: state,\n            printQRInTerminal: false,\n            logger: { level: 'silent' }\n        });\n\n        // Eventos da conex√£o\n        socket.ev.on('connection.update', async (update) => {\n            const { connection, lastDisconnect, qr } = update;\n            \n            if (qr) {\n                console.log('üîó QR Code gerado');\n                qrCodeData = qr;\n                connectionStatus = 'qr_ready';\n                \n                // Notificar Flask que QR est√° pronto\n                await notifyFlask('/webhook/qr-ready', { qr_code: qr });\n            }\n            \n            if (connection === 'close') {\n                const shouldReconnect = (lastDisconnect?.error)?.output?.statusCode !== DisconnectReason.loggedOut;\n                console.log('üîå Conex√£o fechada. Reconectar?', shouldReconnect);\n                isConnected = false;\n                connectionStatus = 'disconnected';\n                \n                await notifyFlask('/webhook/disconnected', { reason: 'connection_closed' });\n                \n                if (shouldReconnect) {\n                    setTimeout(connectToWhatsApp, 3000);\n                }\n            } else if (connection === 'open') {\n                console.log('‚úÖ WhatsApp conectado com sucesso!');\n                isConnected = true;\n                connectionStatus = 'connected';\n                qrCodeData = null;\n                \n                await notifyFlask('/webhook/connected', { \n                    phone: socket.user?.id?.split(':')[0] || 'unknown',\n                    user: socket.user \n                });\n            }\n        });\n\n        // Salvar credenciais quando atualizadas\n        socket.ev.on('creds.update', saveCreds);\n\n        // Receber mensagens\n        socket.ev.on('messages.upsert', async (m) => {\n            const message = m.messages[0];\n            \n            if (!message.key.fromMe && message.message) {\n                const phoneNumber = message.key.remoteJid;\n                const messageText = message.message.conversation || \n                                 message.message.extendedTextMessage?.text || '';\n                \n                if (messageText) {\n                    console.log(`üì® Mensagem recebida de ${phoneNumber}: ${messageText}`);\n                    \n                    // Enviar para Flask processar\n                    await notifyFlask('/webhook/message-received', {\n                        phone: phoneNumber.replace('@s.whatsapp.net', ''),\n                        message: messageText,\n                        contact_name: message.pushName || '',\n                        message_id: message.key.id,\n                        timestamp: new Date().toISOString()\n                    });\n                }\n            }\n        });\n\n    } catch (error) {\n        console.error('‚ùå Erro ao conectar WhatsApp:', error);\n        connectionStatus = 'error';\n        await notifyFlask('/webhook/error', { error: error.message });\n    }\n}\n\n// API Routes\napp.get('/status', (req, res) => {\n    res.json({\n        connected: isConnected,\n        status: connectionStatus,\n        qr_available: !!qrCodeData,\n        user: socket?.user || null\n    });\n});\n\napp.get('/qr', async (req, res) => {\n    if (qrCodeData) {\n        try {\n            const qrImage = await QRCode.toDataURL(qrCodeData);\n            res.json({\n                success: true,\n                qr_code: qrCodeData,\n                qr_image: qrImage\n            });\n        } catch (error) {\n            res.status(500).json({ error: error.message });\n        }\n    } else {\n        res.json({ success: false, message: 'QR Code n√£o dispon√≠vel' });\n    }\n});\n\napp.post('/send-message', async (req, res) => {\n    const { phone, message } = req.body;\n    \n    if (!isConnected) {\n        return res.status(400).json({ error: 'WhatsApp n√£o conectado' });\n    }\n    \n    try {\n        const jid = phone.includes('@') ? phone : `${phone}@s.whatsapp.net`;\n        await socket.sendMessage(jid, { text: message });\n        \n        console.log(`üì§ Mensagem enviada para ${phone}: ${message}`);\n        res.json({ success: true, message: 'Mensagem enviada' });\n    } catch (error) {\n        console.error('‚ùå Erro ao enviar mensagem:', error);\n        res.status(500).json({ error: error.message });\n    }\n});\n\napp.post('/connect', async (req, res) => {\n    if (!isConnected) {\n        await connectToWhatsApp();\n        res.json({ success: true, message: 'Iniciando conex√£o...' });\n    } else {\n        res.json({ success: true, message: 'J√° conectado' });\n    }\n});\n\napp.post('/disconnect', async (req, res) => {\n    if (socket) {\n        await socket.logout();\n        socket = null;\n        isConnected = false;\n        connectionStatus = 'disconnected';\n        qrCodeData = null;\n    }\n    res.json({ success: true, message: 'Desconectado' });\n});\n\n// Iniciar servidor\nconst PORT = 3001;\napp.listen(PORT, () => {\n    console.log(`üöÄ Servidor Baileys rodando na porta ${PORT}`);\n    console.log(`üì± WhatsApp Service iniciado`);\n    \n    // Conectar automaticamente ao iniciar\n    setTimeout(connectToWhatsApp, 1000);\n});\n\n// Tratamento de erros n√£o capturados\nprocess.on('uncaughtException', (error) => {\n    console.error('‚ùå Erro n√£o capturado:', error);\n});\n\nprocess.on('unhandledRejection', (error) => {\n    console.error('‚ùå Promise rejeitada:', error);\n});","size_bytes":6604},"whatsapp_baileys_simple.js":{"content":"const { default: makeWASocket, DisconnectReason, useMultiFileAuthState, downloadMediaMessage } = require('@whiskeysockets/baileys');\nconst QRCode = require('qrcode');\nconst express = require('express');\nconst axios = require('axios');\nconst fs = require('fs');\nconst http = require('http');\n\n// Servidor Express simples\nconst app = express();\napp.use(express.json());\n\n// Estado da aplica√ß√£o\nlet socket = null;\nlet qrCodeData = null;\nlet isConnected = false;\nlet connectionStatus = 'disconnected';\nlet userInfo = null;\n\nconsole.log('üöÄ Iniciando WhatsApp Service...');\n\n// Fun√ß√£o para notificar o Flask\nasync function notifyFlask(endpoint, data) {\n    try {\n        await axios.post(`http://localhost:5000${endpoint}`, data, {\n            headers: { 'Content-Type': 'application/json' },\n            timeout: 3000\n        });\n    } catch (error) {\n        // Ignorar erros de notifica√ß√£o\n    }\n}\n\n// Conectar ao WhatsApp\nasync function connectToWhatsApp() {\n    try {\n        console.log('üì± Conectando ao WhatsApp...');\n        \n        // Usar pasta de auth local\n        const { state, saveCreds } = await useMultiFileAuthState('./whatsapp_auth');\n        \n        socket = makeWASocket({\n            auth: state,\n            printQRInTerminal: false,\n            // Remove logger config to use default\n            browser: ['AsA WhatsApp Bot', 'Chrome', '1.0.0']\n        });\n\n        // Evento de atualiza√ß√£o de conex√£o\n        socket.ev.on('connection.update', async (update) => {\n            const { connection, lastDisconnect, qr } = update;\n            \n            if (qr) {\n                console.log('üîó QR Code gerado!');\n                qrCodeData = qr;\n                connectionStatus = 'qr_ready';\n                \n                // Notificar Flask que QR est√° pronto\n                await notifyFlask('/api/qr-updated', { qr_code: qr });\n            }\n            \n            if (connection === 'close') {\n                const shouldReconnect = (lastDisconnect?.error)?.output?.statusCode !== DisconnectReason.loggedOut;\n                console.log('üîå Conex√£o fechada. Reconectar?', shouldReconnect);\n                \n                isConnected = false;\n                connectionStatus = 'disconnected';\n                qrCodeData = null;\n                userInfo = null;\n                \n                await notifyFlask('/api/disconnected', { reason: 'connection_closed' });\n                \n                if (shouldReconnect) {\n                    console.log('üîÑ Reconectando em 3 segundos...');\n                    setTimeout(connectToWhatsApp, 3000);\n                }\n            } else if (connection === 'open') {\n                console.log('‚úÖ WhatsApp conectado com sucesso!');\n                isConnected = true;\n                connectionStatus = 'connected';\n                qrCodeData = null;\n                userInfo = socket.user;\n                \n                await notifyFlask('/api/connected', { \n                    phone: socket.user?.id?.split(':')[0] || 'unknown',\n                    user: socket.user \n                });\n            }\n        });\n\n        // Salvar credenciais\n        socket.ev.on('creds.update', saveCreds);\n\n        // Receber mensagens\n        socket.ev.on('messages.upsert', async (m) => {\n            const message = m.messages[0];\n            \n            if (!message.key.fromMe && message.message) {\n                const phoneNumber = message.key.remoteJid;\n                \n                // Extrair texto da mensagem\n                let messageText = '';\n                if (message.message.conversation) {\n                    messageText = message.message.conversation;\n                } else if (message.message.extendedTextMessage) {\n                    messageText = message.message.extendedTextMessage.text;\n                }\n                \n                if (messageText && phoneNumber) {\n                    const cleanPhone = phoneNumber.replace('@s.whatsapp.net', '');\n                    console.log(`üì® Mensagem de ${cleanPhone}: ${messageText}`);\n                    \n                    // Enviar para Flask processar\n                    await notifyFlask('/api/message-received', {\n                        phone: cleanPhone,\n                        message: messageText,\n                        contact_name: message.pushName || '',\n                        message_id: message.key.id,\n                        timestamp: new Date().toISOString()\n                    });\n                }\n            }\n        });\n\n    } catch (error) {\n        console.error('‚ùå Erro ao conectar:', error);\n        connectionStatus = 'error';\n        setTimeout(connectToWhatsApp, 5000);\n    }\n}\n\n// API Routes\napp.get('/status', (req, res) => {\n    res.json({\n        connected: isConnected,\n        status: connectionStatus,\n        qr_available: !!qrCodeData,\n        user: userInfo\n    });\n});\n\napp.get('/qr', async (req, res) => {\n    if (qrCodeData) {\n        try {\n            const qrImage = await QRCode.toDataURL(qrCodeData);\n            res.json({\n                success: true,\n                qr_code: qrCodeData,\n                qr_image: qrImage\n            });\n        } catch (error) {\n            res.status(500).json({ error: error.message });\n        }\n    } else {\n        res.json({ success: false, message: 'QR Code n√£o dispon√≠vel' });\n    }\n});\n\napp.post('/send-message', async (req, res) => {\n    const { phone, message } = req.body;\n    \n    if (!isConnected || !socket) {\n        return res.status(400).json({ error: 'WhatsApp n√£o conectado' });\n    }\n    \n    try {\n        let jid = phone;\n        if (!phone.includes('@')) {\n            // Limpar n√∫mero e adicionar @s.whatsapp.net\n            const cleanPhone = phone.replace(/\\D/g, '');\n            jid = `${cleanPhone}@s.whatsapp.net`;\n        }\n        \n        await socket.sendMessage(jid, { text: message });\n        \n        console.log(`üì§ Mensagem enviada para ${phone}: ${message}`);\n        res.json({ success: true, message: 'Mensagem enviada' });\n    } catch (error) {\n        console.error('‚ùå Erro ao enviar mensagem:', error);\n        res.status(500).json({ error: error.message });\n    }\n});\n\napp.post('/set-typing', async (req, res) => {\n    const { phone, typing = true } = req.body;\n    \n    if (!isConnected || !socket) {\n        return res.status(400).json({ error: 'WhatsApp n√£o conectado' });\n    }\n    \n    try {\n        let jid = phone;\n        if (!phone.includes('@')) {\n            const cleanPhone = phone.replace(/\\D/g, '');\n            jid = `${cleanPhone}@s.whatsapp.net`;\n        }\n        \n        await socket.sendPresenceUpdate(typing ? 'composing' : 'paused', jid);\n        res.json({ success: true });\n    } catch (error) {\n        res.status(500).json({ error: error.message });\n    }\n});\n\n// Iniciar servidor\nconst PORT = 3001;\nconst server = app.listen(PORT, () => {\n    console.log(`üöÄ WhatsApp Service rodando na porta ${PORT}`);\n    \n    // Conectar automaticamente\n    setTimeout(connectToWhatsApp, 1000);\n});\n\n// Graceful shutdown\nprocess.on('SIGINT', async () => {\n    console.log('üõë Encerrando WhatsApp Service...');\n    if (socket) {\n        await socket.logout();\n    }\n    server.close(() => {\n        console.log('‚úÖ Servidor encerrado');\n        process.exit(0);\n    });\n});\n\nprocess.on('uncaughtException', (error) => {\n    console.error('‚ùå Erro n√£o capturado:', error);\n});\n\nprocess.on('unhandledRejection', (error) => {\n    console.error('‚ùå Promise rejeitada:', error);\n});","size_bytes":7543},"whatsapp_service.py":{"content":"import os\nimport time\nimport logging\nimport threading\nimport base64\nimport asyncio\nfrom datetime import datetime\nfrom app import app, db\nfrom models import WhatsAppConnection, Conversation, Message, AutoResponse\nfrom ai_service import generate_ai_response, analyze_message_intent\nfrom baileys_service import baileys_service\n\nclass WhatsAppService:\n    \"\"\"Service for managing WhatsApp integration\"\"\"\n    \n    def __init__(self):\n        self.is_connected = False\n        self.typing_threads = {}  # Track typing threads by conversation\n        self.message_queues = {}  # Queue of messages per user\n        self.queue_timers = {}    # Timers for processing queues\n        self.QUEUE_WAIT_TIME = 8   # Seconds to wait for additional messages\n        \n    def generate_qr_code(self):\n        \"\"\"Generate QR code usando Baileys local\"\"\"\n        try:\n            logging.info(\"üì± Gerando QR Code...\")\n            \n            # Aguardar um pouco para o servi√ßo estar pronto\n            time.sleep(2)\n            \n            # Obter QR Code do servi√ßo Baileys\n            qr_result = baileys_service.get_qr_code()\n            \n            if qr_result.get('success'):\n                qr_code = qr_result.get('qr_code', '')\n                qr_base64 = qr_result.get('qr_image', '')\n                \n                with app.app_context():\n                    connection = WhatsAppConnection.query.first()\n                    if not connection:\n                        connection = WhatsAppConnection()\n                        db.session.add(connection)\n                    \n                    connection.qr_code = qr_base64 or qr_code\n                    connection.is_connected = False\n                    db.session.commit()\n                \n                logging.info(\"‚úÖ QR Code gerado com sucesso!\")\n                return qr_base64 or qr_code\n            else:\n                logging.warning(f\"QR Code ainda n√£o est√° pronto: {qr_result.get('message', 'Aguardando...')}\")\n                return None\n                \n        except Exception as e:\n            logging.error(f\"Erro ao gerar QR Code: {e}\")\n            return None\n    \n    def simulate_connection(self):\n        \"\"\"Simulate WhatsApp connection - removed auto-connection\"\"\"\n        # Conex√£o autom√°tica removida - agora s√≥ conecta quando receber confirma√ß√£o real\n        logging.info(\"QR Code gerado - aguardando escaneamento real\")\n    \n    def start_typing_simulation(self, phone_number: str):\n        \"\"\"Start typing simulation for a conversation\"\"\"\n        def typing_worker():\n            # Simulate typing for 2-5 seconds\n            typing_duration = 3\n            logging.info(f\"Typing simulation started for {phone_number}\")\n            time.sleep(typing_duration)\n            logging.info(f\"Typing simulation ended for {phone_number}\")\n        \n        # Cancel existing typing thread if any\n        if phone_number in self.typing_threads:\n            self.typing_threads[phone_number] = None\n        \n        # Start new typing thread\n        thread = threading.Thread(target=typing_worker)\n        self.typing_threads[phone_number] = thread\n        thread.start()\n    \n    def stop_typing_simulation(self, phone_number: str):\n        \"\"\"Stop typing simulation when new message received\"\"\"\n        if phone_number in self.typing_threads:\n            self.typing_threads[phone_number] = None\n            logging.info(f\"Typing simulation interrupted for {phone_number}\")\n    \n    def add_message_to_queue(self, phone_number: str, message_content: str, conversation: Conversation):\n        \"\"\"Add message to queue and manage timer\"\"\"\n        # Initialize queue if not exists\n        if phone_number not in self.message_queues:\n            self.message_queues[phone_number] = []\n        \n        # Add message to queue (save only conversation ID to avoid session issues)\n        self.message_queues[phone_number].append({\n            'content': message_content,\n            'timestamp': datetime.utcnow(),\n            'conversation_id': conversation.id\n        })\n        \n        logging.info(f\"üì• Mensagem adicionada √† fila para {phone_number}. Total na fila: {len(self.message_queues[phone_number])}\")\n        \n        # Cancel existing timer if any\n        if phone_number in self.queue_timers:\n            self.queue_timers[phone_number].cancel()\n        \n        # Start typing simulation\n        self.start_typing_simulation(phone_number)\n        \n        # Create new timer\n        timer = threading.Timer(self.QUEUE_WAIT_TIME, self.process_message_queue, [phone_number])\n        self.queue_timers[phone_number] = timer\n        timer.start()\n        \n        logging.info(f\"‚è±Ô∏è Timer iniciado para {phone_number} ({self.QUEUE_WAIT_TIME}s)\")\n    \n    def process_message_queue(self, phone_number: str):\n        \"\"\"Process all queued messages for a user\"\"\"\n        if phone_number not in self.message_queues or not self.message_queues[phone_number]:\n            return\n        \n        with app.app_context():\n            try:\n                messages = self.message_queues[phone_number].copy()\n                conversation_id = messages[0]['conversation_id']\n                \n                # Clear the queue\n                self.message_queues[phone_number] = []\n                if phone_number in self.queue_timers:\n                    del self.queue_timers[phone_number]\n                \n                # Get fresh conversation object from database in this session\n                conversation = Conversation.query.get(conversation_id)\n                if not conversation:\n                    logging.error(f\"Conversa n√£o encontrada: {conversation_id}\")\n                    return\n                \n                # Check if AI is paused for this conversation\n                if conversation.ai_paused:\n                    logging.info(f\"üö´ IA pausada para {phone_number} - n√£o enviando resposta autom√°tica\")\n                    return\n                \n                logging.info(f\"üîÑ Processando fila de {len(messages)} mensagens para {phone_number}\")\n                \n                # Combine all messages into context\n                combined_messages = []\n                for msg in messages:\n                    combined_messages.append(msg['content'])\n                \n                # Generate single response for all messages\n                response_text = self.generate_response_for_queue(combined_messages, conversation)\n                \n                # Send response\n                self.send_response(conversation, response_text)\n                \n            except Exception as e:\n                logging.error(f\"Erro ao processar fila de mensagens: {e}\")\n                # Try to get conversation for fallback\n                try:\n                    conversation = Conversation.query.filter_by(phone_number=phone_number).first()\n                    if conversation and not conversation.ai_paused:\n                        self.send_response(conversation, \"Desculpe, estou com alguns problemas t√©cnicos. Tente novamente!\")\n                except:\n                    logging.error(f\"N√£o foi poss√≠vel enviar mensagem de fallback para {phone_number}\")\n    \n    def pause_ai_for_conversation(self, phone_number: str):\n        \"\"\"Pause AI responses when human takes over\"\"\"\n        with app.app_context():\n            try:\n                conversation = Conversation.query.filter_by(phone_number=phone_number).first()\n                if conversation:\n                    conversation.ai_paused = True\n                    conversation.paused_at = datetime.utcnow()\n                    db.session.commit()\n                    logging.info(f\"üö´ IA pausada para {phone_number} - humano assumiu o controle\")\n                    \n                    # Clear any pending queue for this user\n                    if phone_number in self.message_queues:\n                        self.message_queues[phone_number] = []\n                    if phone_number in self.queue_timers:\n                        self.queue_timers[phone_number].cancel()\n                        del self.queue_timers[phone_number]\n                        \n            except Exception as e:\n                logging.error(f\"Erro ao pausar IA: {e}\")\n    \n    def process_incoming_message(self, phone_number: str, message_content: str, contact_name: str = \"\"):\n        \"\"\"Process incoming WhatsApp message with queue system\"\"\"\n        with app.app_context():\n            # Stop any ongoing typing simulation\n            self.stop_typing_simulation(phone_number)\n            \n            # Find or create conversation\n            conversation = Conversation.query.filter_by(phone_number=phone_number).first()\n            if not conversation:\n                conversation = Conversation()\n                conversation.phone_number = phone_number\n                conversation.contact_name = contact_name or phone_number\n                db.session.add(conversation)\n                db.session.commit()\n            \n            # Save incoming message\n            incoming_message = Message()\n            incoming_message.conversation_id = conversation.id\n            incoming_message.content = message_content\n            incoming_message.is_from_user = True\n            incoming_message.message_type = 'text'\n            db.session.add(incoming_message)\n            db.session.commit()\n            \n            # Add message to queue\n            self.add_message_to_queue(phone_number, message_content, conversation)\n    \n    def generate_response(self, message_content: str, conversation: Conversation) -> str:\n        \"\"\"Generate AI response using custom prompt for single message\"\"\"\n        try:\n            # Get recent conversation history for context\n            recent_messages = Message.query.filter_by(\n                conversation_id=conversation.id\n            ).order_by(Message.timestamp.desc()).limit(10).all()\n            \n            # Generate AI response using custom prompt\n            return generate_ai_response(message_content, recent_messages[::-1])\n            \n        except Exception as e:\n            logging.error(f\"Erro ao gerar resposta: {e}\")\n            return \"Ol√°! Estou passando por alguns ajustes t√©cnicos. Que tal tentar novamente em alguns minutos?\"\n    \n    def generate_response_for_queue(self, messages_list: list, conversation: Conversation) -> str:\n        \"\"\"Generate AI response for multiple queued messages\"\"\"\n        try:\n            # Get recent conversation history for context\n            recent_messages = Message.query.filter_by(\n                conversation_id=conversation.id\n            ).order_by(Message.timestamp.desc()).limit(10).all()\n            \n            # Combine all queued messages into a single context\n            if len(messages_list) == 1:\n                combined_message = messages_list[0]\n            else:\n                combined_message = f\"O usu√°rio enviou {len(messages_list)} mensagens seguidas:\\n\\n\"\n                for i, msg in enumerate(messages_list, 1):\n                    combined_message += f\"Mensagem {i}: {msg}\\n\"\n                combined_message += f\"\\nPor favor, responda considerando todas essas {len(messages_list)} mensagens de forma integrada.\"\n            \n            logging.info(f\"ü§ñ Gerando resposta IA para {len(messages_list)} mensagens combinadas\")\n            \n            # Generate AI response using custom prompt\n            return generate_ai_response(combined_message, recent_messages[::-1])\n            \n        except Exception as e:\n            logging.error(f\"Erro ao gerar resposta para fila: {e}\")\n            return \"Ol√°! Vi que voc√™ enviou algumas mensagens. Estou com problemas t√©cnicos no momento, mas vou retornar assim que poss√≠vel!\"\n    \n    def send_response(self, conversation: Conversation, response_text: str):\n        \"\"\"Send response message usando Baileys\"\"\"\n        try:\n            # Simular digita√ß√£o antes de enviar\n            baileys_service.set_typing(conversation.phone_number, True)\n            \n            # Aguardar um pouco para simular digita√ß√£o\n            time.sleep(2)\n            \n            # Enviar mensagem via Baileys\n            send_result = baileys_service.send_message(conversation.phone_number, response_text)\n            \n            # Parar digita√ß√£o\n            baileys_service.set_typing(conversation.phone_number, False)\n            \n            if send_result.get('success'):\n                # Salvar no banco apenas se envio foi bem-sucedido\n                response_message = Message()\n                response_message.conversation_id = conversation.id\n                response_message.content = response_text\n                response_message.is_from_user = False\n                response_message.message_type = 'text'\n                response_message.response_type = 'ai'\n                \n                db.session.add(response_message)\n                conversation.updated_at = datetime.utcnow()\n                db.session.commit()\n                \n                logging.info(f\"üì§ Mensagem enviada via Baileys para {conversation.phone_number}\")\n            else:\n                logging.error(f\"‚ùå Erro ao enviar via Baileys: {send_result.get('error')}\")\n                \n        except Exception as e:\n            logging.error(f\"Erro ao enviar resposta: {e}\")\n    \n    def get_connection_status(self):\n        \"\"\"Get current connection status do Baileys\"\"\"\n        with app.app_context():\n            connection = WhatsAppConnection.query.first()\n            if not connection:\n                connection = WhatsAppConnection()\n                db.session.add(connection)\n                db.session.commit()\n            \n            # Verificar status no servi√ßo Baileys\n            try:\n                baileys_status = baileys_service.get_connection_status()\n                \n                if baileys_status.get('success') != False:\n                    # Atualizar status no banco baseado no Baileys\n                    is_connected = baileys_status.get('connected', False)\n                    \n                    connection.is_connected = is_connected\n                    if is_connected:\n                        connection.last_connected = datetime.utcnow()\n                        connection.qr_code = None\n                    \n                    db.session.commit()\n                    \n                    return {\n                        'is_connected': connection.is_connected,\n                        'qr_code': connection.qr_code,\n                        'last_connected': connection.last_connected,\n                        'baileys_status': baileys_status.get('status', 'unknown'),\n                        'qr_available': baileys_status.get('qr_available', False),\n                        'user_info': baileys_status.get('user'),\n                        'service_running': True\n                    }\n                else:\n                    return {\n                        'is_connected': False,\n                        'qr_code': connection.qr_code,\n                        'last_connected': connection.last_connected,\n                        'baileys_status': 'service_error',\n                        'service_running': False,\n                        'error': baileys_status.get('error', 'Servi√ßo n√£o est√° rodando')\n                    }\n                    \n            except Exception as e:\n                # Fallback para status local\n                return {\n                    'is_connected': connection.is_connected,\n                    'qr_code': connection.qr_code,\n                    'last_connected': connection.last_connected,\n                    'baileys_status': 'error',\n                    'service_running': False,\n                    'error': str(e)\n                }\n\n# Global service instance\nwhatsapp_service = WhatsAppService()\n\ndef simulate_incoming_messages():\n    \"\"\"Simulate incoming messages for testing\"\"\"\n    import random\n    \n    sample_messages = [\n        (\"5511999999999\", \"Ol√°\", \"Jo√£o Silva\"),\n        (\"5511888888888\", \"Preciso de ajuda\", \"Maria Santos\"),\n        (\"5511777777777\", \"Qual o hor√°rio de funcionamento?\", \"Pedro Costa\"),\n        (\"5511666666666\", \"Obrigado pelo atendimento\", \"Ana Lima\"),\n    ]\n    \n    def send_test_message():\n        time.sleep(random.randint(10, 30))\n        phone, message, name = random.choice(sample_messages)\n        whatsapp_service.process_incoming_message(phone, message, name)\n        logging.info(f\"Test message sent: {message}\")\n    \n    # Start background thread for test messages\n    threading.Thread(target=send_test_message, daemon=True).start()\n","size_bytes":16638},"static/css/custom.css":{"content":"/* Custom CSS for AsA WhatsApp System */\n\n:root {\n    --asa-primary: #25d366;\n    --asa-secondary: #128c7e;\n    --asa-accent: #075e54;\n    --asa-light: #dcf8c6;\n}\n\n/* Custom WhatsApp-inspired colors */\n.text-whatsapp {\n    color: var(--asa-primary) !important;\n}\n\n.bg-whatsapp {\n    background-color: var(--asa-primary) !important;\n}\n\n.btn-whatsapp {\n    background-color: var(--asa-primary);\n    border-color: var(--asa-primary);\n    color: white;\n}\n\n.btn-whatsapp:hover {\n    background-color: var(--asa-secondary);\n    border-color: var(--asa-secondary);\n    color: white;\n}\n\n/* QR Code display styling */\n.qr-code-display {\n    padding: 2rem;\n    background: white;\n    border-radius: 10px;\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n    display: inline-block;\n    text-align: center;\n    min-width: 200px;\n}\n\n#qr-code-container {\n    animation: fadeIn 0.5s ease-in;\n}\n\n@keyframes fadeIn {\n    from { opacity: 0; transform: translateY(20px); }\n    to { opacity: 1; transform: translateY(0); }\n}\n\n/* Connection status indicators */\n.connection-indicator {\n    position: relative;\n}\n\n.connection-indicator::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: -10px;\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    background-color: var(--bs-success);\n    animation: pulse 2s infinite;\n}\n\n.connection-indicator.disconnected::before {\n    background-color: var(--bs-danger);\n}\n\n@keyframes pulse {\n    0% { transform: scale(0.95); opacity: 1; }\n    70% { transform: scale(1); opacity: 0.7; }\n    100% { transform: scale(0.95); opacity: 1; }\n}\n\n/* Message bubbles for conversation view */\n.message-bubble {\n    max-width: 80%;\n    padding: 0.75rem 1rem;\n    margin: 0.5rem 0;\n    border-radius: 18px;\n    position: relative;\n    word-wrap: break-word;\n}\n\n.message-from-user {\n    background-color: var(--asa-light);\n    color: #000;\n    margin-left: auto;\n    margin-right: 0;\n    text-align: right;\n}\n\n.message-from-bot {\n    background-color: var(--bs-light);\n    color: var(--bs-dark);\n    margin-left: 0;\n    margin-right: auto;\n}\n\n.message-timestamp {\n    font-size: 0.75rem;\n    opacity: 0.7;\n    margin-top: 0.25rem;\n}\n\n/* Typing indicator */\n.typing-indicator {\n    display: flex;\n    align-items: center;\n    padding: 0.5rem 1rem;\n    background-color: var(--bs-light);\n    border-radius: 18px;\n    margin: 0.5rem 0;\n    width: fit-content;\n}\n\n.typing-dots {\n    display: flex;\n    gap: 4px;\n}\n\n.typing-dot {\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    background-color: var(--bs-secondary);\n    animation: typingAnimation 1.4s infinite ease-in-out;\n}\n\n.typing-dot:nth-child(2) {\n    animation-delay: 0.2s;\n}\n\n.typing-dot:nth-child(3) {\n    animation-delay: 0.4s;\n}\n\n@keyframes typingAnimation {\n    0%, 60%, 100% {\n        transform: translateY(0);\n        opacity: 0.5;\n    }\n    30% {\n        transform: translateY(-10px);\n        opacity: 1;\n    }\n}\n\n/* Admin dashboard enhancements */\n.stats-card {\n    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;\n}\n\n.stats-card:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n}\n\n.stats-icon {\n    font-size: 2.5rem;\n    opacity: 0.8;\n}\n\n/* Response cards */\n.response-card {\n    transition: transform 0.2s ease-in-out;\n    border-left: 4px solid var(--asa-primary);\n}\n\n.response-card:hover {\n    transform: translateY(-2px);\n}\n\n.response-preview {\n    max-height: 120px;\n    overflow: hidden;\n    position: relative;\n}\n\n.response-preview::after {\n    content: '';\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    height: 20px;\n    width: 100%;\n    background: linear-gradient(transparent, var(--bs-body-bg));\n}\n\n/* Loading states */\n.loading-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.5);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    z-index: 9999;\n}\n\n.loading-spinner {\n    color: var(--asa-primary);\n    font-size: 3rem;\n}\n\n/* Toast container positioning */\n.toast-container {\n    z-index: 1055;\n}\n\n.toast {\n    min-width: 300px;\n}\n\n/* Form enhancements */\n.form-floating .form-control:focus ~ label {\n    color: var(--asa-primary);\n}\n\n.form-control:focus {\n    border-color: var(--asa-primary);\n    box-shadow: 0 0 0 0.2rem rgba(37, 211, 102, 0.25);\n}\n\n/* Button enhancements */\n.btn-outline-primary:hover,\n.btn-outline-primary:focus {\n    background-color: var(--asa-primary);\n    border-color: var(--asa-primary);\n}\n\n/* Table improvements */\n.table-hover tbody tr:hover {\n    background-color: rgba(37, 211, 102, 0.1);\n}\n\n/* Responsive improvements */\n@media (max-width: 768px) {\n    .qr-code-display {\n        padding: 1rem;\n        min-width: 150px;\n    }\n    \n    .message-bubble {\n        max-width: 90%;\n    }\n    \n    .stats-card {\n        margin-bottom: 1rem;\n    }\n}\n\n/* Accessibility improvements */\n.btn:focus,\n.form-control:focus,\n.nav-link:focus {\n    outline: 2px solid var(--asa-primary);\n    outline-offset: 2px;\n}\n\n/* Animation for page transitions */\n.fade-in {\n    animation: fadeIn 0.3s ease-in;\n}\n\n.slide-up {\n    animation: slideUp 0.3s ease-out;\n}\n\n@keyframes slideUp {\n    from {\n        opacity: 0;\n        transform: translateY(30px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n/* Status badges */\n.badge {\n    font-size: 0.75em;\n    font-weight: 500;\n}\n\n/* Custom scrollbar for webkit browsers */\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: var(--bs-light);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: var(--asa-primary);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: var(--asa-secondary);\n}\n\n/* Print styles */\n@media print {\n    .navbar,\n    .btn,\n    .modal,\n    .toast-container {\n        display: none !important;\n    }\n    \n    .container {\n        max-width: none !important;\n    }\n}\n","size_bytes":5944},"static/js/main.js":{"content":"// Main JavaScript file for AsA WhatsApp System\n\n// Global utility functions\nfunction showAlert(message, type = 'info') {\n    const alertHtml = `\n        <div class=\"alert alert-${type} alert-dismissible fade show\" role=\"alert\">\n            ${message}\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        </div>\n    `;\n    \n    // Insert at the top of main content\n    const mainContent = document.querySelector('main .container');\n    if (mainContent) {\n        mainContent.insertAdjacentHTML('afterbegin', alertHtml);\n    }\n}\n\n// Auto-hide alerts after 5 seconds\ndocument.addEventListener('DOMContentLoaded', function() {\n    const alerts = document.querySelectorAll('.alert');\n    alerts.forEach(alert => {\n        setTimeout(() => {\n            const bsAlert = new bootstrap.Alert(alert);\n            bsAlert.close();\n        }, 5000);\n    });\n});\n\n// Connection status monitoring\nclass ConnectionMonitor {\n    constructor() {\n        this.isMonitoring = false;\n        this.interval = null;\n    }\n    \n    start() {\n        if (this.isMonitoring) return;\n        \n        this.isMonitoring = true;\n        this.interval = setInterval(() => {\n            this.checkStatus();\n        }, 10000); // Check every 10 seconds\n    }\n    \n    stop() {\n        if (this.interval) {\n            clearInterval(this.interval);\n            this.interval = null;\n        }\n        this.isMonitoring = false;\n    }\n    \n    async checkStatus() {\n        try {\n            const response = await fetch('/connection_status');\n            const data = await response.json();\n            \n            const statusElement = document.getElementById('connection-status');\n            if (statusElement && data.is_connected) {\n                // Reload page if connection status changed to connected\n                if (!statusElement.innerHTML.includes('Conectado ao WhatsApp')) {\n                    location.reload();\n                }\n            }\n        } catch (error) {\n            console.error('Error checking connection status:', error);\n        }\n    }\n}\n\n// Initialize connection monitor on relevant pages\nconst connectionMonitor = new ConnectionMonitor();\nif (document.getElementById('connection-status')) {\n    connectionMonitor.start();\n}\n\n// QR Code generation\nasync function generateQRCode() {\n    const button = document.getElementById('generate-qr-btn');\n    if (!button) return;\n    \n    const originalText = button.innerHTML;\n    button.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i>Gerando...';\n    button.disabled = true;\n    \n    try {\n        const response = await fetch('/generate_qr');\n        const data = await response.json();\n        \n        if (!data.success) {\n            throw new Error(data.error || 'Erro ao gerar QR Code');\n        }\n        \n        const qrDisplay = document.getElementById('qr-display');\n        if (qrDisplay && data.qr_image) {\n            qrDisplay.innerHTML = `\n                <div class=\"qr-code-display text-center\">\n                    <img src=\"${data.qr_image}\" alt=\"QR Code\" class=\"qr-image mb-3\" style=\"max-width: 300px; width: 100%;\">\n                    <p class=\"mt-2 mb-1 text-dark\"><strong>C√≥digo gerado!</strong></p>\n                    <small class=\"text-muted\">Escaneie com seu WhatsApp</small>\n                </div>\n            `;\n        } else {\n            throw new Error('QR Code n√£o dispon√≠vel');\n        }\n        \n        // Start monitoring for connection\n        connectionMonitor.start();\n        \n        showAlert('C√≥digo QR gerado! Escaneie com seu WhatsApp.', 'success');\n        \n        // Mostrar bot√£o de simular escaneamento para teste\n        const simulateBtn = document.getElementById('simulate-scan-btn');\n        if (simulateBtn) {\n            simulateBtn.style.display = 'inline-block';\n        }\n        \n    } catch (error) {\n        console.error('Error generating QR code:', error);\n        showAlert('Erro ao gerar c√≥digo QR. Tente novamente.', 'danger');\n    } finally {\n        button.innerHTML = originalText;\n        button.disabled = false;\n    }\n}\n\n// Test message functionality\nasync function sendTestMessage() {\n    const messageInput = document.getElementById('test-message');\n    const button = document.getElementById('send-test-btn');\n    \n    if (!messageInput || !button) return;\n    \n    const message = messageInput.value.trim();\n    if (!message) {\n        showAlert('Digite uma mensagem para testar.', 'warning');\n        return;\n    }\n    \n    const originalText = button.innerHTML;\n    button.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i>Enviando...';\n    button.disabled = true;\n    \n    try {\n        const response = await fetch('/api/simulate_message', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n                phone: '5511999999999',\n                message: message,\n                name: 'Usu√°rio Teste'\n            })\n        });\n        \n        const data = await response.json();\n        \n        if (data.status === 'success') {\n            showAlert('Mensagem de teste enviada com sucesso! Verifique o painel admin.', 'success');\n            messageInput.value = '';\n        } else {\n            throw new Error('Erro na resposta do servidor');\n        }\n        \n    } catch (error) {\n        console.error('Error sending test message:', error);\n        showAlert('Erro ao enviar mensagem de teste.', 'danger');\n    } finally {\n        button.innerHTML = originalText;\n        button.disabled = false;\n    }\n}\n\n// Simulate QR scan for testing\nasync function simulateScan() {\n    const button = document.getElementById('simulate-scan-btn');\n    if (!button) return;\n    \n    const originalText = button.innerHTML;\n    button.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i>Conectando...';\n    button.disabled = true;\n    \n    try {\n        const response = await fetch('/simulate_scan');\n        const data = await response.json();\n        \n        if (data.status === 'connected') {\n            showAlert('WhatsApp conectado com sucesso!', 'success');\n            setTimeout(() => {\n                location.reload();\n            }, 1500);\n        } else {\n            throw new Error('Erro na conex√£o');\n        }\n        \n    } catch (error) {\n        console.error('Error simulating scan:', error);\n        showAlert('Erro ao simular escaneamento.', 'danger');\n    } finally {\n        button.innerHTML = originalText;\n        button.disabled = false;\n    }\n}\n\n// Event listeners\ndocument.addEventListener('DOMContentLoaded', function() {\n    // QR Code generation button\n    const generateQRBtn = document.getElementById('generate-qr-btn');\n    if (generateQRBtn) {\n        generateQRBtn.addEventListener('click', generateQRCode);\n    }\n    \n    // Test message button\n    const sendTestBtn = document.getElementById('send-test-btn');\n    if (sendTestBtn) {\n        sendTestBtn.addEventListener('click', sendTestMessage);\n    }\n    \n    // Simulate scan button\n    const simulateScanBtn = document.getElementById('simulate-scan-btn');\n    if (simulateScanBtn) {\n        simulateScanBtn.addEventListener('click', simulateScan);\n    }\n    \n    // Auto-focus on password field in login page\n    const passwordField = document.getElementById('password');\n    if (passwordField && window.location.pathname.includes('login')) {\n        passwordField.focus();\n    }\n    \n    // Form validation for response forms\n    const responseForm = document.querySelector('form[action*=\"responses\"]');\n    if (responseForm) {\n        responseForm.addEventListener('submit', function(e) {\n            const keyword = document.getElementById('trigger_keyword');\n            const response = document.getElementById('response_text');\n            \n            if (keyword && keyword.value.trim().length < 2) {\n                e.preventDefault();\n                showAlert('A palavra-chave deve ter pelo menos 2 caracteres.', 'warning');\n                keyword.focus();\n                return;\n            }\n            \n            if (response && response.value.trim().length < 5) {\n                e.preventDefault();\n                showAlert('A resposta deve ter pelo menos 5 caracteres.', 'warning');\n                response.focus();\n                return;\n            }\n        });\n    }\n});\n\n// Real-time updates for admin dashboard\nclass DashboardUpdater {\n    constructor() {\n        this.updateInterval = null;\n    }\n    \n    start() {\n        if (this.updateInterval) return;\n        \n        // Update every 30 seconds\n        this.updateInterval = setInterval(() => {\n            this.updateStats();\n        }, 30000);\n    }\n    \n    stop() {\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n            this.updateInterval = null;\n        }\n    }\n    \n    async updateStats() {\n        // This would fetch updated statistics\n        // For now, we'll just refresh the page occasionally\n        if (Math.random() < 0.1) { // 10% chance to refresh\n            location.reload();\n        }\n    }\n}\n\n// Initialize dashboard updater on admin pages\nif (window.location.pathname.includes('/admin/')) {\n    const dashboardUpdater = new DashboardUpdater();\n    dashboardUpdater.start();\n}\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', function() {\n    connectionMonitor.stop();\n});\n\n// Toast notifications for better UX\nfunction showToast(message, type = 'info') {\n    // Create toast container if it doesn't exist\n    let toastContainer = document.getElementById('toast-container');\n    if (!toastContainer) {\n        toastContainer = document.createElement('div');\n        toastContainer.id = 'toast-container';\n        toastContainer.className = 'toast-container position-fixed top-0 end-0 p-3';\n        toastContainer.style.zIndex = '1055';\n        document.body.appendChild(toastContainer);\n    }\n    \n    const toastId = 'toast-' + Date.now();\n    const toastHtml = `\n        <div class=\"toast\" id=\"${toastId}\" role=\"alert\">\n            <div class=\"toast-header\">\n                <i class=\"fas fa-info-circle text-${type} me-2\"></i>\n                <strong class=\"me-auto\">AsA</strong>\n                <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"toast\"></button>\n            </div>\n            <div class=\"toast-body\">\n                ${message}\n            </div>\n        </div>\n    `;\n    \n    toastContainer.insertAdjacentHTML('beforeend', toastHtml);\n    \n    const toastElement = document.getElementById(toastId);\n    const toast = new bootstrap.Toast(toastElement);\n    toast.show();\n    \n    // Remove toast element after it's hidden\n    toastElement.addEventListener('hidden.bs.toast', function() {\n        this.remove();\n    });\n}\n\n// Export for global use\nwindow.AsA = {\n    showAlert,\n    showToast,\n    generateQRCode,\n    sendTestMessage,\n    connectionMonitor\n};\n","size_bytes":10961}}}